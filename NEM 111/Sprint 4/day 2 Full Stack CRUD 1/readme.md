### Today's Agenda
Yesterday's Revision
Better way of passing token
Hashing  --npm package
Plan backend application --Notes taking app
Make express appluication (with basic routes)

### Tomorrow's Agenda
Relationship implementation
Frontend (using React)
How to connect Frontend and Backend

### Day after Tomorrow's agenda
Deploy everything
API Documentation (Swagger)

### ----------------------------------------------------

### Yesterday's revision
Authentication: verifying identity
Authorization: Access permission
Register route - posted data in db
login route - comparing email and password with one in db and authetication
For authentication and authorisation I need token.
Token should be always unique and random hence I used JWT.
JWT- JSON Web Token
Can be used for Authentication, Authorisation and Transfering data
3 importatnt components of JWT: 
    1. Header - it has-> Encryption algorithm, type of token
    2. Payload - Any random data which will help us in creation of token
    3. Verifying signature - Secret key by the help of which I can decode token

While visiting private routes, I can use this decoded token


### To see my database and all in GUI, I am using mongodb compass app that I have installed. Just click connect and you will see all your databases.

So whenever you do some changes to your database, just do a refresh in compass and the changes will reflect over there as well.



### Better way of passing token and accessing token
In frontend, we used to pass token like this
fetch(backend url,{
    method : "POST",
    headers : {
        authorization : `Bearer ${token}`  //standard way of passing
    }
})

So in backend I should access token like: 
Accessing token:
    const token = req.headers.authorization

I a m going to pass `Bearer ${token}` i.e a string. And I want only token out of it. So i'll first convert string to array by spilt. And then access index no. 1 from it. Because token is at index 1.


I have to always verify token while openeing the private routes. Hence I will cerate a middleware whose task will be to verify the token.


### Hashing 

    Converting one string into another unreadable string.
    abc ---------->  hgsdufygwsy

    Admin can easily see what's the user's password if its not hashed. Hence hadhing the password is necessary.

    So I should hash the password before storing into the database.
    Hence do hashing in registration route. 
    Before user.save()

    (Check diff between hashing and encryption)

    for hashing:  Refer npm doc of bcrypt
    npm i bcrypt

    Where to write code for it?
    I want to hash my passord before storing it inside the db
    i.e during registration.

    bcrypt is designed to slow dow n the process.
    If someone tries to hack so he'll have a hard time coz bcrypt is designed to slow down the process
    saltRounds: Number of times passsword hasa to be hashed.
    abc ---------->  hgsdufygwsy -------> hsdgfuhysdfgs ----> ghdsfuhasduh
                    saltRound 1           saltRound 2         saltRound 3

    The more the saltrounds, the more slower it is so 5 is more than enough

    In npm bcrypt doc, 
    under "Usage"
    under "To hash password"
    THere are 2 techniques.
    We will use 2nd one, because 1st one has 2 callback functions.
    2nd one has only one and it has autogenerated salt rounds.

    bcrypt.hash(myPlaintextPassword, saltRounds, function(err, hash) {
        // Store hash in your password DB.
    })  

    -myPlaintextPassword : normal password
    -saltRounds : No. of times the password has to be hashed.
    -hash : hashed password


    While logging, I'll have to convert the hashed password to actual password, because I want to compare the passwords. i.e the one which user enters while logging in and the one which is present in db. But db vala password is hashed password, hence I need to convert before comparing.

    In npm bcrypt doc, 
    under "Usage"
    under "To check a password:"

    bcrypt.compare(myPlaintextPassword, hash, function(err, result) {
        // result == true
    })

    -myPlaintextPassword : normal password
    -hash : hashed password


### Notes taking app


    User routes:
            /users/register  ==> To register a new user
            /users/login     ===> For Authenticating the registered user

For below routes to work, the user needs to be authenticated (that user should have a token)(So we will put these routes under auth middleware)
    Notes Routes
            /notes/create ==> Creating a new note
            (Need to check who is making changes or getting notes)
            user is an independent collection and notes is a dependent collection
            i.e one to many relationship
            /notes  ===> To get all created notes
            /notes/update/:noteID : To update any note
            /notes/delete/:noteID : To delete a note


Write remaining logics